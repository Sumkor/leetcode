package com.sumkor.dp._0375_guess;

import org.junit.Assert;
import org.junit.Test;

/**
 * @author Sumkor
 * @since 2021/9/24
 */
public class Solution04 {

    /**
     * 动态规划
     * https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/
     *
     *
     *
     * 1. 为什么使用动态规划，不使用二分？
     *
     * 动态规划与二分的区别在哪里呢？
     * 使用动态规划的好处在于我可以穷举所有的情况，对于这个题来说，就是指动态规划的方法可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。
     * 举个例子：
     *
     * 当 n=5：
     * 动态规划：1 2 3 4 5 在第一次猜数时，我们可以猜 1,2,3,4,5
     * 二分查找：1 2 3 4 5 在第一次猜数时，我们只能猜 3
     *
     * 为什么要使用动态规划猜所有的数字呢？
     * 当 n=5，假如我第一次猜 3，那么需要 7；假如我第一次猜 4，只需要 6.
     * 很显然 6 才是正确答案，使用二分法虽然方便，但是是错误的。所以我使用动态规划穷举所有情况。
     *
     *
     *
     * 2. 对于二维数组 dp[i][j] 的理解
     *
     * 动态规划需要使用内存储存计算过的结果，在这里我使用一个二维数组 dp[n+1][n+1]
     *
     * 对于动态规划来说，需要明白 dp[i][j] 的含义。
     * dp[i][j] 是说依次以从 i 到 j 的数字作为分割点(猜的数)，必定赢的游戏所用钱的最小值。
     * 这样看起来似乎很难理解。
     *
     * (1) 解释 dp[1][1]:
     * dp[1][1]是指只有一个数字 1，我们以 1 作为分割点(猜的数)，赢得游戏所用钱的最小值，一看就知道，dp[1][1]=0。因为我们只能猜 1，答案也只能是 1，不用花钱
     *
     * (2) 解释 dp[1][2]:
     * dp[1][2]是指只有两个数字 1，2
     *
     * 我们先以 1 作为分割点(猜的数):
     *
     * 猜 1：
     * 答案是 1，花费 0 元
     * 答案是 2，花费 1 元
     * 必定赢得游戏，最多花费 1 元
     *
     * 我们再以 2 作为分割点(猜的数):
     *
     * 猜 2：
     * 答案是 1，花费 2 元
     * 答案是 2，花费 0 元
     * 必定赢得游戏，最多花费 2 元
     *
     * 综上，只要进入 [1,2] 这个区间，我们第一次猜 1，只要花费 1 元，必定可以赢得游戏（假如看不懂，再看一次，细细的品）
     * 所以 dp[1][2]=1 (只要花 1 元必定赢得游戏，当第一次猜 1 时)
     *
     * (3) 解释 dp[2][3]:
     * dp[2][3] 是指只有两个数字 2，3
     *
     * 有一个小问题，为什么不是从 1 开始呢？(明白的不用看)
     * 比如 n=3，我们第一次猜了 1，但是答案是 2 或者 3，反正不是 1，我们是不是要到 [2,3] 区间来寻找答案，即求
     * dp[2][3]
     *
     * 我们先以 2 作为分割点(猜的数):
     *
     * 猜 2：
     * 答案是 2，花费 0 元
     * 答案是 3，花费 2 元
     * 必定赢得游戏，最多花费 2 元
     *
     * 我们再以 3 作为分割点(猜的数):
     *
     * 猜 3：
     * 答案是 2，花费 3 元
     * 答案是 3，花费 0 元
     * 必定赢得游戏，最多花费 3 元
     *
     * 综上，只要进入 [2,3] 这个区间，我们第一次猜 2，只要花费 2 元，必定可以赢得游戏
     * 所以 dp[2][3]=2 (只要花 2 元必定赢得游戏，当第一次猜 2 时)
     *
     * (4) 解释 dp[1][3]:
     * dp[1][3]是指只有三个数字 1，2，3
     *
     * 我们先以 1 作为分割点(猜的数):
     *
     * 猜 1：
     * 答案是 1，花费 0 元
     * 答案是 2 或者 3，这个时候会进入另一个区间 [2,3]，花费 1+dp[2][3] 元
     * 必定赢得游戏，最多花费 max(0, 1+dp[2][3])元
     *
     * 我们再以 2 作为分割点(猜的数):
     *
     * 猜 2：
     * 答案是 1，花费 2+dp[1][1] = 2+0 = 2 元
     * 答案是 2，花费 0 元
     * 答案是 3，花费 2+dp[3][3] = 2+0 = 2 元
     * 必定赢得游戏，最多花费 max(0, 2+dp[1][1], 2+dp[3][3]) 元
     *
     * 我们最后以 3 作为分割点(猜的数):
     *
     * 猜 3：
     * 答案是 1 或者 2，花费 3+dp[1][2] 元
     * 答案是 3，花费 0 元
     * 必定赢得游戏，最多花费 max(0, 3+dp[1][2]) 元
     *
     * 综上，只要进入 [1][3] 这个区间，我们只要花费 min( max(0,1+dp[2][3]), max(0,2+dp[1][1],2+dp[3][3]), max(0,3+dp[1][2]) ) 元必定可以赢的游戏
     * 而 dp[1][3] 也就等于那个 min 的值。
     *
     * 可以发现，只要找到 dp[1][n] 即可。
     * (假如不能明白 dp[i][j] 可以返回上面内容看例子，明白后再往下阅读)
     *
     *
     *
     * 3.状态转移方程
     *
     * 状态转移方程怎么写呢？
     * 看第 4 个例子，dp[1][3] 我们就可以发现：
     * 对于每一个分割点，我们取它左右两边区间的最大值加上分割点本身作为取此分割点的 dp[i][j] 值
     * 对于每一个区间，我们取所有分割点的 dp[i][j] 的最小值作为 dp[i][j] 的真正的值
     * 特别地，对于以 i 作为分割点的 dp[i][j]，只取 i 右边的区间；对于以 j 作为分割点的 dp[i][j]，只取 j 左边的区间
     *
     * 这个我觉得看懂 dp[1][3] 不难理解，要是理解不了的话，我这样解释一下(明白的不用看)：
     *
     * i i+1 i+2 ... ... j-2 j-1 j
     *
     * 以 i+1 为分割点对应的： dp1 = max(dp[i][i], dp[i+2][j]) + i+1
     * 以 j-1 为分割点对应的: dp2 = max(dp[i][j-2], dp[j][j]) + j-1
     * 特别地，以 i 为分割点： dp0 = i + dp[i+1][j]; 以 j 为分割点: dp3 = j + dp[i][j-1]
     * dp[i][j] = min(dp0,dp1,dp2,dp3)
     *
     *
     *
     * 4.数组填充
     *
     * 给出一个 dp 二维数组来用代码填充它，“\”表示正无穷
     *
     * (1)初始化：         (2)易知dp[i][i]=0
     * | \ \ \ \ |         | 0 \ \ \ |
     * | \ \ \ \ |         | \ 0 \ \ |
     * | \ \ \ \ |         | \ \ 0 \ |
     * | \ \ \ \ |         | \ \ \ 0 |
     *
     * 接下来要考虑怎么填充矩阵以得到 dp[1][n]:
     * 很容易我们发现可以用一个位置左边和下边地数据来计算它本身，因此可以这样填充
     *
     * (3)填充 1 列：
     * | 0 1 \ \ |  dp[1][2]计算步骤向上看
     * | \ 0 \ \ |
     * | \ \ 0 \ |
     * | \ \ \ 0 |
     *
     * (4)再填充 1 列：
     * | 0 1 x \ |  dp[1][3]计算步骤向上看
     * | \ 0 2 \ |  dp[2][3]计算步骤向上看(先填充)
     * | \ \ 0 \ |
     * | \ \ \ 0 |
     *
     * (5)再填充最后一列:
     * | 0 1 x x |  dp[1][4]计算步骤向上看
     * | \ 0 2 x |  dp[2][4]计算步骤向上看(然后填充)
     * | \ \ 0 x |  dp[3][4]计算步骤向上看(先填充)
     * | \ \ \ 0 |
     * x 都是因为我懒得算了... ... 偷个懒，有兴趣可以自己算
     *
     * 上述问题搞清楚就可以来写代码了
     *
     * 执行用时：21 ms, 在所有 Java 提交中击败了45.45% 的用户
     * 内存消耗：37.5 MB, 在所有 Java 提交中击败了58.84% 的用户
     */
    public int getMoneyAmount(int n) {
        if (n == 1) {
            return 0;
        }
        // 定义矩阵
        int[][] dp = new int[n + 1][n + 1];
        // 初始化“\”
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        //定义基础值dp[i][i]
        for (int i = 0; i <= n; i++) {
            dp[i][i] = 0;
        }
        // 按列来，从第 2 列开始
        for (int j = 2; j <= n; j++) {
            // 按行来，从下往上
            for (int i = j - 1; i >= 1; i--) {
                // 算除了两端的每一个分割点
                for (int k = i + 1; k <= j - 1; k++) {
                    dp[i][j] = Math.min(k + Math.max(dp[i][k - 1], dp[k + 1][j]), dp[i][j]);
                }
                // 算两端
                dp[i][j] = Math.min(dp[i][j], i + dp[i + 1][j]);
                dp[i][j] = Math.min(dp[i][j], j + dp[i][j - 1]);
            }
        }
        return dp[1][n];
    }

    /**
     * dp[i][j]表示我从[i,j]之前选择一个数字你来猜，你确保获胜所需要的最少现金
     *
     * 转移方程：
     * dp[i][j] = min(
     *                 i + dp[i + 1][j],
     *                 ...
     *                 k + max(dp[i][k - 1], dp[k + 1][j]),  (k 从 i + 1 到 j - 1)
     *                 ...
     *                 j + dp[i][j - 1]
     *               )
     *
     * 返回: dp[1][n]
     *
     * 执行用时：16 ms, 在所有 Java 提交中击败了82.58% 的用户
     * 内存消耗：37.4 MB, 在所有 Java 提交中击败了82.58% 的用户
     */
    public int getMoneyAmount1(int n) {
        if (n == 1) return 0;
        int[][] dp = new int[n + 1][n + 1];
        for (int j = 2; j <= n; j++) {
            for (int i = j - 1; i >= 1; i--) {
                int a = Math.min(i + dp[i + 1][j], j + dp[i][j - 1]);
                int b = Integer.MAX_VALUE;
                for (int k = i + 1; k <= j - 1; k++) {
                    int tmp = k + Math.max(dp[i][k - 1], dp[k + 1][j]);
                    b = Math.min(b, tmp);
                }
                dp[i][j] = Math.min(a, b);
            }
        }
        return dp[1][n];
    }

    @Test
    public void test() {
        int[][] a = new int[2][3]; // 两行，每行三个

        int n = 10;
        int moneyAmount = getMoneyAmount(n);
        Assert.assertEquals(16, moneyAmount);

    }
}
